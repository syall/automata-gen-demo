{"version":3,"sources":["index.js","AutomataGenDemo.js"],"names":["ReactDOM","render","emptyCell","state","display","aliveCell","initRules","options","random","range","cell","weight","stateRules","nbInfo","prev","count","runningRules","msPerStep","maxIterations","useState","g","Automata","generateGrid","initGrid","world","grid","setGrid","running","setRunning","dimension","cols","size","worldStyle","gridTemplateColumns","gridGap","backgroundColor","border","cellStyle","width","height","textAlign","lineHeight","fontSize","updateCell","i","k","tempGrid","row","rows","col","defaultCell","getRandomCell","calculateTotalWeight","update","start","updateGrid","a","async","sleep","className","onClick","style","map","key","displayCell","document","getElementById"],"mappings":"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","file":"static/js/main.d3a6b58a.chunk.js","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport AutomataGenDemo from './AutomataGenDemo';\n\nReactDOM.render(<AutomataGenDemo />, document.getElementById('root'));\n","import React, { useState } from 'react';\nimport { Automata } from 'automata-gen';\nimport './AutomataGenDemo.css';\n\nexport default function AutomataGenDemo() {\n\n  // Automata Definition\n\n  /** */\n  const emptyCell = { state: 0, display: '0' };\n  const aliveCell = { state: 1, display: '1' };\n  const initRules = {\n    options: {\n      random: true,\n      range: [\n        { cell: emptyCell, weight: 7 },\n        { cell: aliveCell, weight: 3 },\n      ]\n    },\n  };\n  const stateRules = [\n    (nbInfo, prev) => nbInfo.count < 2 || nbInfo.count > 3 ? emptyCell : false,\n    (nbInfo, prev) => nbInfo.count === 3 ? aliveCell : false,\n  ];\n  const runningRules = {\n    msPerStep: 100,\n    maxIterations: 250,\n  };\n  const initGrid = () => {\n    const g = new Automata(\n      initRules,\n      stateRules,\n      runningRules,\n    );\n    g.generateGrid();\n    return g;\n  };\n  /**/\n  /*\n  const emptyCell = { state: 'empty', display: ' ' };\n  const treeCell = { state: 'tree', display: 'ðŸŒ²' };\n  const burningCell = { state: 'burning', display: 'ðŸ”¥' };\n  const probabilityBurn = 0.001;\n  const probabilityTree = 0.01;\n  const initRules = {\n    rows: 25,\n    cols: 25,\n    options: {\n      random: true,\n      range: [\n        { cell: emptyCell, weight: 3 },\n        { cell: treeCell, weight: 7 },\n      ]\n    },\n  };\n  const stateRules = [\n    (nbInfo, prev) => prev.state === 'burning' ? emptyCell : false,\n    (nbInfo, prev) =>\n      prev.state === 'tree' && nbInfo.neighbors['burning']?.count >= 1\n        ? burningCell\n        : false\n    ,\n    (nbInfo, prev) => Math.random() < probabilityBurn ? burningCell : false,\n    (nbInfo, prev) => Math.random() < probabilityTree ? treeCell : false,\n  ];\n  const runningRules = {\n    msPerStep: 100,\n    maxIterations: 250,\n  };\n  const initGrid = () => {\n    const g = new Automata(\n      initRules,\n      stateRules,\n      runningRules,\n    );\n    g.generateGrid();\n    return g;\n  };\n  */\n  /*\n  const e = { state: 'empty', display: ' ' };\n  const h = { state: 'head', display: 'H' };\n  const t = { state: 'tail', display: 't' };\n  const c = { state: 'conductor', display: '.' };\n  const initRules = {\n    grid: [\n      [t, h, c, c, c, c, c, c, c, c, c],\n      [c, e, e, e, c, e, e, e, e, e, e],\n      [e, e, e, c, c, c, e, e, e, e, e],\n      [c, e, e, e, c, e, e, e, e, e, e],\n      [h, t, c, c, e, c, c, c, c, c, c],\n    ],\n    options: { range: [{ cell: e, weight: 1 }] },\n  };\n  const stateRules = [\n    (nbInfo, prev) => prev.state === 'empty' ? e : false,\n    (nbInfo, prev) => prev.state === 'head' ? t : false,\n    (nbInfo, prev) => prev.state === 'tail' ? c : false,\n    (nbInfo, prev) =>\n      prev.state === 'conductor' && (\n      nbInfo.neighbors['head']?.count === 1 ||         nbInfo.neighbors['head']?.count === 2)\n        ? h\n        : false,\n    (nbInfo, prev) => prev.state === 'conductor' ? c : false,\n  ];\n  const runningRules = {\n    msPerStep: 100,\n    maxIterations: 250,\n  };\n  const initGrid = () => {\n    const g = new Automata(\n      initRules,\n      stateRules,\n      runningRules,\n    );\n    g.defaultCell = e;\n    return g;\n  };\n  */\n\n  // State\n  const [world] = useState(initGrid());\n  const [grid, setGrid] = useState(world.grid);\n  const [running, setRunning] = useState(world.running);\n\n  // Style\n  const dimension = world.cols;\n  const size = `calc(80vmin / ${dimension})`;\n  const worldStyle = {\n    display: 'grid',\n    gridTemplateColumns: `repeat(${dimension}, ${size})`,\n    gridGap: '1px',\n    backgroundColor: 'black',\n    border: '1px solid black'\n  };\n  const cellStyle = {\n    width: `${size}`,\n    height: `${size}`,\n    backgroundColor: 'white',\n    textAlign: 'center',\n    lineHeight: `${size}`,\n    fontSize: `3vmin`\n  };\n\n  // Update Cell\n  const updateCell = i => k => () => {\n    if (running)\n      return;\n    const tempGrid = world.generateGrid(false);\n    for (let row = 0; row < world.rows; row++)\n      for (let col = 0; col < world.cols; col++)\n        tempGrid[row][col] =\n          row === i && col === k\n            ? grid[row][col].state === world.defaultCell.state\n              ? world.getRandomCell(world.calculateTotalWeight())\n              : world.defaultCell\n            : grid[row][col];\n    setGrid(tempGrid);\n  };\n\n  // Display\n  const displayCell = col => col ? col.display : world.defaultCell.display;\n  const displayGrid = () => grid.map((rows, i) =>\n    rows.map((col, k) => (\n      <div className='cell'\n        key={`r${i}c${k}`}\n        style={cellStyle}\n        onClick={updateCell(i)(k)}\n      >\n        {displayCell(col)}\n      </div>\n    ))\n  );\n\n  // Update Grid\n  const update = start => () => {\n    if (running && !start)\n      return;\n    world.updateGrid();\n    setGrid(world.grid);\n  };\n\n  // Start Automata\n  const start = () => {\n    if (running)\n      return;\n    setRunning(true);\n  };\n  const step = async () => {\n    await world.sleep();\n    await update(true)();\n  };\n  const run = async () => running && await step();\n  run();\n\n  // Stop Automata\n  const stop = () => {\n    if (!running)\n      return;\n    setRunning(false);\n  };\n\n  // Empty Automata\n  const emptyGrid = () => {\n    if (running)\n      return;\n    world.grid = world.generateGrid(false);\n    setGrid(world.grid);\n  };\n\n  // Fill Automata\n  const fillGrid = () => {\n    if (running)\n      return;\n    world.grid = world.generateGrid(true);\n    setGrid(world.grid);\n  };\n\n  return (\n    <>\n      <p className='title'>automata-gen demo</p>\n      <aside className='controls'>\n        <button className='control' onClick={update(false)}>Step</button>\n        <button className='control' onClick={start}>Start</button>\n        <button className='control' onClick={stop}>Stop</button>\n        <button className='control' onClick={emptyGrid}>Empty</button>\n        <button className='control' onClick={fillGrid}>Random</button>\n      </aside>\n      <main className='world' style={worldStyle}>\n        {displayGrid()}\n      </main>\n    </>\n  );\n};\n"],"sourceRoot":""}